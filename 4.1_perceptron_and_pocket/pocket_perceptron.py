import copy
import time

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # need to keep this for 3D plot


# from mpl_toolkits.mplot3d import Axes3D  # need to keep this for 3D plot


def get_data(fname='classification.txt'):
    """
        given a file name, return a pandas data frame
        assume separated by comma
    """
    data_raw = np.array(pd.read_csv(fname, sep=",", header=None))
    X, y = data_raw[:, :3], data_raw[:, 4]
    return X, y


class PocketPerceptron:
    def __init__(self, X, y, max_iter=7000, learning_rate=1):
        self.X = X
        self.y = y
        self.weights = np.ones((4,))  # init weights as dimension + 1, for ease of matrix calc
        self.max_iter = max_iter
        self.learning_rate = learning_rate

        # pocket params
        self.least_error = 7001
        self.best_weight = None
        self.error_count_list = np.zeros(7000)

    def fit(self):
        x_zero = np.ones((self.X.shape[0], 1))  # bias value add to X.
        self.X = np.concatenate((x_zero, self.X), axis=1)  # init X0 as 1

        for i in range(self.max_iter):
            # get random entry from the data set
            rand_idx = np.random.randint(0, len(self.X) - 1)
            dp = self.X[rand_idx]

            # get current expected value and compare with the real one.
            cur_expected = self.get_expected(dp)
            cur_y = self.y[rand_idx]

            if cur_expected != cur_y:
                # update the weights accordingly
                self.weights += self.learning_rate * dp * cur_y

                # compare current accuracy with previous ones
                cur_error_count = self.verify()
                self.error_count_list[i] = cur_error_count
                if cur_error_count < self.least_error:
                    self.best_weight = copy.deepcopy(self.weights)  # shallow copy is enough here, right?
                    self.least_error = cur_error_count

            else:
                # copy past error count to current
                if i == 0:
                    self.error_count_list[i] = self.verify()
                else:
                    self.error_count_list[i] = self.error_count_list[i - 1]

        return self.best_weight, self.error_count_list

    def get_expected(self, x_vals):
        # result = np.sum(np.dot(self.weights, x_vals))
        result = np.dot(self.weights, x_vals)
        return self.get_sign(result)

    def get_sign(self, val):
        if val > 0:
            return 1
        else:
            return -1

    def verify(self, selected_weights=None):
        if selected_weights is not None:
            cur_weights = selected_weights
        else:
            cur_weights = self.weights

        error_count = 0
        predictions = np.dot(self.X, cur_weights)
        for pred, expect in zip(predictions, y):
            if self.get_sign(pred) != expect:
                error_count += 1

        return error_count


def plotter(X, y, weights=None):
    # plot 3d data points
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    dp1, dp2 = [], []
    for dp, cur_y in zip(X, y):
        if cur_y == 1:
            dp1.append(dp)
        else:
            dp2.append(dp)
    dp1 = np.array(dp1)
    dp2 = np.array(dp2)

    # scatter for raw data
    ax.scatter(dp1[:, 0], dp1[:, 1], dp1[:, 2], color='red', marker='^')
    ax.scatter(dp2[:, 0], dp2[:, 1], dp2[:, 2], color='blue', marker='^')

    # plot the hyper plane by weights
    point = np.array([0, 0, 0])
    normal = np.array(weights[1:])
    d = -point.dot(normal)

    # create x,y
    xx, yy = np.meshgrid(range(2), range(2))
    z = (-normal[0] * xx - normal[1] * yy - d) * 1. / normal[2]
    ax.plot_surface(xx, yy, z, alpha=0.2)

    ax.set_xlabel('X Label')
    ax.set_ylabel('Y Label')
    ax.set_zlabel('Z Label')

    plt.legend()
    plt.title('Pocket Perceptron Algorithm\n3D data points with hyper plane generated by weights')
    plt.show()


start = time.clock()  # see how long it takes to run this code
X, y = get_data()
percep_algo = PocketPerceptron(X, y)
result_weights, error_list = percep_algo.fit()

print('takes {} sec\n\n'.format(time.clock() - start))
print('result best weights:{}'.format(result_weights))
print('result best accuracy:{}'.format(1 - percep_algo.verify(result_weights) * 1.0 / len(X)))
print('least error count:{}'.format(percep_algo.verify(result_weights)))

plotter(X, y, result_weights)
plt.plot(np.arange(0, 7000), error_list)  # print the error list
plt.show()
